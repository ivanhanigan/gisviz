#+TITLE:gisviz overview 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Introduction
** DESCRIPTION-code
#+name:DESCRIPTION
#+begin_src R :session *R* :tangle DESCRIPTION :exports none :eval no :padline no
Package: gisviz
Type: Package
Title: GIS visualisation and data manipulation tools
Version: 1.0
Date: 2012-12-18
Author: ivanhanigan
Maintainer: <ivan.hanigan@gmail.com>
Depends: RCurl, XML, ggmap, maps, maptools, RColorBrewer, spdep, rgdal
Description:  Functions I modified or created for visualising GIS data in population health and environmental science projects.
License: GPL (>= 2)
#+end_src

** run tests
#+name:test_project
#+begin_src R :session *R* :tangle test_project.r :exports none :eval no
  ################################################################
  # name:test_project
  require(testthat)
  test_dir('tests')
  
#+end_src

** package doc
#+name:swishdbtools-package
#+begin_src R :session *R* :tangle man/gisviz-package.Rd :exports none :eval no
\name{gisviz-package}
\alias{gisviz-package}
\alias{gisviz}
\docType{package}
\title{
GIS visualisation tools
}
\description{
General visualisations.
}
\details{
\tabular{ll}{
Package: \tab gisviz\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2012-12-18\cr
License: \tab GPL (>= 2)\cr
}
}
\author{
ivanhanigan

Maintainer: Who to complain to <ivan.hanigan@gmail.com>

}
\references{

}
\keyword{ package }
\seealso{
}
\examples{
}

#+end_src

**  loadall-code
#+name:loadall
#+begin_src R :session *R* :tangle no :exports none :eval yes
  ################################################################
  # name:loadall
  #dir("R")
  require(devtools)
  load_all()
  
#+end_src

#+RESULTS: loadall

* functions
** adjacency_df
*** R-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle R/adjacency_df.r :exports none :eval no
################################################################
# name:adjacency_df
adjacency_df <- function(NB, shp, zone_id)
  {
    adjacencydf <- as.data.frame(matrix(NA, nrow = 0, ncol = 2))
    for(i in 1:length(NB))
    {
      if(length(shp[[zone_id]][NB[[i]]]) == 0) next
      adjacencydf <- rbind(adjacencydf, cbind(as.character(shp[[zone_id]][i]),as.character(shp[[zone_id]][NB[[i]]])))
    }
    return(adjacencydf)
  }
#+end_src
*** test-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle tests/test-adjacency_df.r :exports none :eval no
  ################################################################
  # name:adjacency_df
  require(devtools)
  load_all()
  require(spdep)
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  class(eire)
  eire@data
  
  plot(eire)
  nb <- poly2nb(eire)
  head(nb)
  eire[['names']][1]
  eire[['names']][nb[[1]]]
  plot(nb, coordinates(eire), add=TRUE, pch=".", lwd=2)
  adj <- adjacency_df(NB = nb, shp = eire, zone_id = 'names')
  adj
  
  
#+end_src
*** man-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:adjacency_df

#+end_src
** choropleth
*** test-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle no :exports none :eval yes
  ################################################################
  # name:choropleth
  require(gisviz)
  require(devtools)
  load_all()
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  class(eire)
  eire@data
  
  plot(eire)
  
  eire2 <- spTransform(eire, CRS("+proj=longlat +datum=WGS84"))
  ?choropleth
  png("test.png")
  choropleth(stat="INCOME", region.map=eire2, scalebar = T, xl = c(-8,-6), yl = c(52,53))
  dev.off()
  
#+end_src

#+RESULTS: choropleth

*** R-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle R/choropleth.r :exports none :eval no
  
  ################################################################
  # name:choropleth
  ################################################################
  # A general mapping function, form of which was taken from here:
  # http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r
  ################################################################
  
  choropleth <- function(maptitle = 'map', stat=NA, region.map=NA,
                      brew.pal = "RdYlBu",
                      invert.brew.pal = TRUE,
                      cellsmap=region.map, scalebar = TRUE,
                      xl = NA, yl = NA,
                      probs=seq(0,1,.2)
                      )
  {
    level.labels <- get.levels(cellsmap=cellsmap,stat=stat,probs=probs)
    # create a new variable in cells.map to bin the data into categories
    cells.map <- cellsmap
    bins <- quantile(cells.map@data[,stat], probs, na.rm=T)
    cells.map@data$bins <- cut(cells.map@data[,stat],
                               bins, include.lowest=TRUE
                               )
    # Replace the character "levels" attribute with character colors
    col.vec <- brewer.pal(length(level.labels),brew.pal)
    if(invert.brew.pal == TRUE) col.vec <- col.vec[length(col.vec):1]
    levels(cells.map@data$bins) <- col.vec
    # Open a windows graphics device so that we can see what's happening
    # windows(11.7,8.3)
    # Split the figure to leave room at the right for a legend, and room
    # at the top margin for a title
    par(fig = c(0,0.7,0,1), mar=c(2,2,2,0))
    # plot the map object with no border around the rectangels, and with colors
    # dictated by new variable we created, which holds the colours as its levels
    # paramater.
  
    if(!is.na(xl)  & !is.na(yl))
      {
        plot(cells.map,
             border = FALSE,
             axes = FALSE,
             las = 1,
             col = as.character(cells.map@data$bins),
             xlim = xl, ylim = yl
             )
      } else {
        plot(cells.map,
             border = FALSE,
             axes = FALSE,
             las = 1,
             col = as.character(cells.map@data$bins)
             )
      }
    if(scalebar == FALSE)
      {
        axis(1);axis(2)
      } else {
        map.scale(ratio=F)
      }
  
    box()
    plot(region.map, add=TRUE, lwd=1)
    mtext(maptitle, side = 3, cex = 2, line = 0)
    par(fig = c(0.7,1,0,1), mar=c(0,0,0,0), new = FALSE)
    legend("left", level.labels, fill=col.vec, bty="n", xpd=TRUE,
          title="Legend")
  
  }
  
#+end_src
*** man-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle man/choropleth.Rd :exports none :eval no
  \name{choropleth}
  \alias{choropleth}
  %- Also NEED an '\alias' for EACH other topic documented here.
  \title{
  Plot a Choropleth Map
  }
  \description{
  Plot a Choropleth Map
  }
  \usage{
  choropleth(stat = NA, plotdir = getwd(), probs = seq(0, 1, 0.2), outfile = NA, maptitle = "map", cellsmap = NA, region.map = NA)
  }
  %- maybe also 'usage' for other objects documented here.
  \arguments{
    \item{maptitle}{
  
  }
    \item{stat}{
  the column with the statistic to be plotted
  }
    \item{region.map}{
  if using a polygon
  }
   \item{brew.pal}{
  defaults to RdYlBu.  use display.brewer.all() to see options
  }
   \item{invert.brew.pal}{
   inverted colour ramp
  }
    \item{cellsmap}{
  if using a raster etc can be used to show pattern inside polygons, defaults to region.map and therefore overlays.
  }
    \item{scalebar}{
  if set to false then the axes are ploted
  }
  \item{xl}{
  xlim values
}
\item{yl}{
ylim values
}
    \item{probs}{
  quantiles at which to break, default is quintiles, limit is 9
  }
  
  
  
  }
  \value{
  a map
  }
  \references{
  http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r
  
  Eduardo Leoni
  http://stackoverflow.com/a/1261288
  }
  \author{
  ivanhanigan
  }
  \examples{
  require(gisviz)
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  eire2 <- spTransform(eire, CRS("+proj=longlat +datum=WGS84"))
  png("test.png")
  choropleth(stat="INCOME", region.map=eire2, scalebar = T, xl = c(-8,-6), yl = c(52,53))
  dev.off()

  Sr1 = Polygon(cbind(c(2,4,4,1,2),c(2,3,5,4,2)))
  Sr2 = Polygon(cbind(c(5,4,2,5),c(2,3,2,2)))
  Sr3 = Polygon(cbind(c(4,4,5,10,4),c(5,3,2,5,5)))
  Sr4 = Polygon(cbind(c(5,6,6,5,5),c(4,4,3,3,4)), hole = TRUE)
  Srs1 = Polygons(list(Sr1), "s1")
  Srs2 = Polygons(list(Sr2), "s2")
  Srs3 = Polygons(list(Sr3, Sr4), "s3/4")
  SpP = SpatialPolygons(list(Srs1,Srs2,Srs3), 1:3)
  plot(SpP, col = 1:3, pbg="white")
  attr = data.frame(a=1:3, b=3:1, row.names=c("s3/4", "s2", "s1"))
  SrDf = SpatialPolygonsDataFrame(SpP, attr)
  plot(SrDf)
  choropleth("title", stat = "b",region.map= SrDf)
  }
  
#+end_src
*** TODO versions
*** COMMENT arribas-code
#+name:arribas
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:arribas https://raw.github.com/darribas/darribas-R-tools/master/choropleth.r
##################################
# Choropleth: thematic maps in R #
##################################

# Author: Daniel Arribas-Bel <daniel.arribas.bel@gmail.com>
# Copyright 2010 by Daniel Arribas-Bel 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    See: <http://creativecommons.org/licenses/GPL/2.0/> or <http://www.gnu.org/licenses/>

library(maptools)
library(spatial)
library(RColorBrewer)
library(classInt)

gpclibPermit()

dbf.choropleths <- function(link, dims=FALSE, excluded=c(), 
                            classMethod='quantile', bins=5,
                            border='black'){
    shp <- paste(link, 'shp', sep='.')
    dbf <- paste(link, 'dbf', sep='.')
    png <- paste(link, '_choropleths.png', sep='')
    dbf <- read.dbf(dbf)
    k <- length(dbf[1, ])
    png(png, width=4670, height=2000, bg='white')
    if(dims==FALSE){
        s = sqrt(k)
        s = (s - s%%1) + 1
        dims = c(s, s)
    }
    par = par(mfrow=dims)
    vars <- names(dbf)
    vars <- vars[!(vars %in% excluded)]

    for(var in seq(length(vars))){
        print(paste('Building var', vars[var]))
        name <- vars[var]

        choropleth(shp, name, bins=bins, style=classMethod,
        title=name, font=10, legend=FALSE, border=border)
        }

    dev.off()
}

choropleth <- function(shp, field, png=FALSE, bins=FALSE, bgLayer=FALSE,
        colPal="Blues", style="hclust", lwd=0.5, title='', sub='', xlab='',
        ylab='', legend=TRUE, font=4, tcol='black', texto='', width=960,
        height=960, border='black'){
            # If not 'bins' -> categorical data
            poly <- readShapeSpatial(shp, force_ring=TRUE)
            attach(poly@data, warn.conflicts=FALSE)
            data <- get(field)
            if(bins==FALSE){
                bins <- length(unique(get(field)))
                colCode <- colCoder(poly, field, colPal)
                leyenda <- colCode$legend
                fill <- colCode$paleta
                colCode <- colCode$colVec
                } else {
                colors <- brewer.pal(bins, colPal)
                class = classIntervals(data, bins, style)
                colCode = findColours(class, colors, digits=4)
                leyenda = names(attr(colCode, "table"))
                fill = attr(colCode, "palette")
                }
            detach(poly@data)
            #
            if(png!=FALSE){
                png(png, width=width, height=height, bg="white")
                #png(png, width=960, height=960, bg="white")
                }
            if(bgLayer!=FALSE){
                polyBg <- readShapeSpatial(bgLayer, force_ring=TRUE)
                plot(polyBg, lwd=lwd, border=border)
                plot(poly, add=TRUE, col=colCode, lwd=lwd)
                } else {
                plot(poly, col=colCode, lwd=lwd, border=border)
                }
            title(main=title, sub=sub, xlab=xlab, ylab=ylab, cex.main=font,
            col.main=tcol, cex.sub=font, cex.lab=font)
            if(texto!=''){
                text(-1, -1, texto)
                }
            if(legend==TRUE){legend("topleft", legend=leyenda, fill=fill, cex=0.75, bty="n")}
            if(png!=FALSE){
                dev.off()
                }
            "Map created"
            }

colCoder <- function(poly, var, colPal){
            attach(poly@data, warn.conflicts=FALSE)
            uniques <- unique(get(var))
            paleta <- brewer.pal(length(uniques), colPal)
            colVec <- mat.or.vec(length(get(var)), 1)
            for(row in seq(length(get(var)))){
                ind <- which(uniques == get(var)[row])
                colVec[row] <- paleta[ind]
                }
            detach(poly@data)
            res <- list(colVec=colVec, legend=uniques, paleta=paleta)
            res
            }


#+end_src

** get.levels
*** test-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src
*** R-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle R/get.levels.r :exports none :eval no
################################################################
# name:get.levels

################################################################
# name:cells

################################################################################
# Function to return bin sizes for the map key            
################################################################################
get.levels = function(stat,cellsmap, probs=seq(0,1,.2)){
  cells.map=cellsmap
  bins = quantile(cells.map@data[,stat], probs, na.rm=T)  
  binlevels = cut(cells.map@data[,stat], bins, include.lowest=TRUE)
  groups = strsplit(levels(binlevels), ",")
# Get the beginning value for each group
  begins = sapply(groups, '[[', 1)
  begins = substr(begins, 2, nchar(begins))
# Get the beginning value for each group
  ends = sapply(groups, '[[', 2)
  ends = substr(ends, 1, nchar(ends)-1)
# Put begins and ends together into labels
  level.labels = paste(begins, ends, sep = " - ")
  qlevels = paste(as.character(probs[2:length(probs)]*100),"%:",sep="") 
  level.labels = paste(qlevels, level.labels)  
return(level.labels) 
}  
#get.levels(cellsmap=d,stat='DAILY_MAX_')

#+end_src
*** man-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src

** gGeoCode2
*** R-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle R/gGeoCode2.r :exports none :eval yes
  ################################################################
  # name:gGeoCode2
  
  getDocNodeVal <- function(doc, path){
    sapply(getNodeSet(doc, path), function(el) xmlValue(el))
  }
  
  gGeoCode2 <- function(str, first=T){  
    if(!is.data.frame(str) & length(str) == 1)
    {
      str2 <- gsub(' ','%20',str)
      u <- sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str2)
      xml.response <- getURL(u, ssl.verifypeer=FALSE)
      
      doc <- xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
      
      
      
      lat <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
      lng <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
      if(length(lng) == 1 & first == F){
        
        out <- c(str, lng, lat)
      } else if(length(lng) >= 1 & first == T) {
        out<-c(str, lng[1], lat[1])
      } else {
        out<-c(str, NA, NA)
      }
      out<-as.data.frame(t(out))
    } else {
      
      if(is.data.frame(str)){
        if(ncol(str) == 1)
          {
            str <- as.character(str[,1])
          } else {
        stop("only character vectors or singlecolumn dataframes allowed")
        }
      }
      
      pointTable<-as.data.frame(matrix(nrow=0, ncol=3))
      for(index in 1: length(str))
      {
        #index <- 1
        str2 <- gsub(' ','%20',str[index])
  
        u <- sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str2)
        xml.response <- getURL(u, ssl.verifypeer=FALSE)
        
        doc <- xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
        
        
        
        lat <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
        lng <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
        
        if(length(lng) == 1 & first == F){
          
          out <- c(str[index], lng, lat)
        } else if(length(lng) >= 1 & first == T) {
          out<-c(str[index], lng[1], lat[1])
        } else {
          out<-c(str[index], NA, NA)
        }
        pointTable<-rbind(pointTable,as.data.frame(t(out)))
      }
      #names(pointTable)<-c('Location', 'Latitude', 'Longitude')
      out <- pointTable
    }
  
    names(out) <- c('address','long','lat')
    out$long <- as.numeric(as.character(out$long))
    out$lat <- as.numeric(as.character(out$lat))
    
    return(out)
    
  }
  
#+end_src

#+RESULTS: gGeoCode2

*** test-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle tests/test-gGeoCode2.r :exports none :eval yes
    ################################################################
    # name:gGeoCode2
    #source("../R/gGeoCode2.r")
    require(testthat)
    require(devtools)
    load_all()
  
    address <- "1 Lineaus way acton canberra"
    address2 <- c("1 Lineaus way acton canberra", "15 follett street scullin")
    address3 <- as.data.frame(address2)
    xy <- gGeoCode2(address)
    xy <- gGeoCode2(address2)
    xy <- gGeoCode2(address3)
    xy
    str(xy)
     
     
    address <- "1 Lineaus way acton canberra"
    locn <-   gGeoCode2(address)
    str(locn)
    test_that("address is returned",
    {
      expect_that(nrow(
                       gGeoCode2(address)
                       ) == 1, is_true())
    }
    )
#+end_src
*** man-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle man/gGeoCode2.Rd :exports none :eval no
\name{gGeoCode2}
\alias{gGeoCode2}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
gGeoCode2
}
\description{
This is an HTTPS security enhanced version of the gGeoCode function from Ezgraphs. GoogleGeocodeMap.R, 2010. https://github.com/ezgraphs/R-Programs/blob/master/GoogleGeocodeMap.R. 
}
\usage{
gGeoCode2(str, first = T)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{str}{
address string
}
  \item{first}{
google may return multiple hits.  just return the first.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
%%  ~~who you are~~
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
address <- "1 Lineaus way acton canberra"
gGeoCode2(address)
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ geocoding }
\keyword{ address }% __ONLY ONE__ keyword per line

#+end_src

*** COMMENT versions-code
#+name:versions
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:gGeoCode2
  
  getDocNodeVal <- function(doc, path){
      sapply(getNodeSet(doc, path), function(el) xmlValue(el))
    }
  
  gGeoCode2 <- function(str, first=T){  
    if(!is.data.frame(str) & length(str) == 1)
    {
      str2 <- gsub(' ','%20',str)
      u <- sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str2)
      xml.response <- getURL(u, ssl.verifypeer=FALSE)
      
      doc <- xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
      
      
      
      lat <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
      lng <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
      if(length(lng) == 1 & first == F){
        
        out <- c(str, lng, lat)
      } else if(length(lng) >= 1 & first == T) {
        out<-c(str, lng[1], lat[1])
      } else {
        out<-c(str, NA, NA)
      }
      out<-as.data.frame(t(out))
    } else {
      
      if(is.data.frame(str)){
        if(ncol(str) == 1)
          {
            str <- as.character(str[,1])
          } else {
        stop("only character vectors or singlecolumn dataframes allowed")
        }
      }
      
      pointTable<-as.data.frame(matrix(nrow=0, ncol=3))
      for(index in 1: length(str))
      {
        #index <- 1
        str2 <- gsub(' ','%20',str[index])
  
        u <- sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str2)
        xml.response <- getURL(u, ssl.verifypeer=FALSE)
        
        doc <- xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
        
        
        
        lat <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
        lng <- getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
        
        if(length(lng) == 1 & first == F){
          
          out <- c(str[index], lng, lat)
        } else if(length(lng) >= 1 & first == T) {
          out<-c(str[index], lng[1], lat[1])
        } else {
          out<-c(str[index], NA, NA)
        }
        pointTable<-rbind(pointTable,as.data.frame(t(out)))
      }
      #names(pointTable)<-c('Location', 'Latitude', 'Longitude')
      out <- pointTable
    }
  
    names(out) <- c('address','long','lat')
    out$long <- as.numeric(as.character(out$long))
    out$lat <- as.numeric(as.character(out$lat))
    
    return(out)
    
  }
  
  
  
  # address <- "1 Lineaus way acton canberra"
   address2 <- c("1 Lineaus way acton canberra", "15 follett street scullin")
   address3 <- as.data.frame(address2)
  # xy <- gGeoCode2(address)
   xy <- gGeoCode2(address2)
   xy <- gGeoCode2(address3)
   xy
  str(xy)
#+end_src

** plotMyMap
*** test-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:plotMyMap
  plotMyMap('canberra', googlemaps = T)
#+end_src
*** R-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle R/plotMyMap.R :exports none :eval no
################################################################
# name:plotMyMap
plotMyMap <- function(location, xl = c(-180,180), yl = c(-50,50), googlemaps = F){
  map('world', xlim = xl, ylim = yl)
  box()
  if(diff(xl) > 300) {
    axis(1);axis(2)
  } else {
    map.scale(ratio=F)
  }
  if(googlemaps == T){
    points(geocode(location), pch =16, col = 'red')
  } else {
    points(location[1,], pch =16, col = 'red')
  }
  
}


#+end_src
*** man-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:plotMyMap

#+end_src

** postgis_concordance
*** COMMENT postgis_concordance-code
#+name:postgis_concordance
#+begin_src R :session *R* :tangle R/postgis_concordance.r :exports none :eval yes
  ################################################################
  # name:postgis_concordance
  postgis_concordance <- function(conn, source_table, source_zones_code,
                                  target_table, target_zones_code,
                                  into = paste(source_table, "_concordance", sep = ""),
                                  tolerance = 0.01,
                                  subset_target_table = NA, 
                                  eval = F
                                  )
  {
    
  sql <- paste("
  select source_zone_code, source_zones, 
    target_fid, target_zone_code, prop_olap_src_of_tgt,
    prop_olap_src_segment_of_src_orig, geom
  frominto
  (
  select    src.zone_code as source_zone_code,
            tgt.gid as target_fid, tgt.zone_code as target_zone_code, source_zones,
            st_intersection(src.geom, tgt.geom) as geom,
            st_area(src.geom) as src_area,
            st_area(tgt.geom) as tgt_area,
            st_area(st_intersection(src.geom, tgt.geom )) as area_overlap,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(tgt.geom) as
            prop_olap_src_of_tgt,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(src.geom) as
            prop_olap_src_segment_of_src_orig
  from
  (
  select ",source_zones_code," as zone_code, cast('",source_table,"' as text) as source_zones, geom
  from ",source_table,"
  ) src,
  (
  select gid, ",target_zones_code," as zone_code, geom
  from ",target_table,"
  ) tgt
  where st_intersects(src.geom, tgt.geom)
  ) concorded
  where prop_olap_src_of_tgt > ",tolerance,";
  grant select on ",into," to public_group;
  ", sep = "")
    
  # if table exists add inserts, else
  if(length(grep("\\.",into)) == 0)
  {
    schema <- "public"
    table <- into
  } else {
    schema <- strsplit(into, "\\.")[[1]][1]
    table <- strsplit(into, "\\.")[[1]][2]
  }
  
  tableExists <- pgListTables(conn, schema, table)
    
  if(nrow(tableExists) != 0)
    {
      stop("table exists")
    } else {
      sql <-  gsub("frominto", paste("into ", into, "\nfrom", sep = ""), sql)
    }
  
    sql2 <- paste("\n
      alter table ",into," add column gid serial primary key;
      ", sep = "")
    sql3 <- paste("\n
      ALTER TABLE ",into," ALTER COLUMN geom SET NOT NULL;
      ", sep = "")
    sql4 <- paste("\n
      CREATE INDEX ",strsplit(into, "\\.")[[1]][2],"_gist on ",into," using GIST(geom);
      ", sep = "")
    sql5 <- paste("\n
      ALTER TABLE ",into," CLUSTER ON ",strsplit(into, "\\.")[[1]][2],"_gist;
      ", sep = "")
      
  if(!is.na(subset_target_table))
    {
      sql <- gsub(") tgt", paste("where ", subset_target_table, "\n) tgt", sep = ""), sql)
    }
  if(eval)
    {
      dbSendQuery(conn, sql)
      dbSendQuery(conn, sql2)
      dbSendQuery(conn, sql3)
      dbSendQuery(conn, sql4)
      dbSendQuery(conn, sql5)    
    } else {
      return(c(sql, sql2, sql3, sql4, sql5))
    }
    
  }
    
#+end_src

#+RESULTS: postgis_concordance

*** COMMENT test-postgis_concordance
#+name:postgis_concordance
#+begin_src R :session *R* :tangle tests/test-postgis_concordance.r :exports none :eval yes
  require(swishdbtools)
  ch <- connect2postgres2("django")
  pwd <- getPassword()
  zone_layers <- c('99','00', '01', '02', '03', '04', '05', '06', '07')
  for(zn in zone_layers)
    {
      dbSendQuery(ch,
                  sprintf("drop table public.test%s" , zn)
                  )
    }
  
  ## yy <- "98"
  ## sql <- postgis_concordance(
  ##                            conn = ch
  ##                            ,
  ##                            source_table = sprintf("abs_sla.nswsla%s", yy)
  ##                            ,
  ##                            source_zones_code = "sla_code"
  ##                            ,
  ##                            target_table = "abs_sla.nswsla98"
  ##                            ,
  ##                            target_zones_code = "sla_code"
  ##                            ,
  ##                            into = "public.test98"
  ##                            ,
  ##                            tolerance = 0.01
  ##                            ,
  ##                            subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'"
  ##                            ,
  ##                            eval = T
  ##                            )
  ## #cat(sql)
  ## sql_subset(ch , "public.test98", subset = "cast(target_zone_code as text) like '%0750'", eval = T)
  
  
  #dbSendQuery(ch, "drop table public.test99")
  for(yy in zone_layers)
    {
  #    yy <- "99"
      sql <- postgis_concordance(conn = ch, source_table = sprintf("abs_sla.nswsla%s", syy),  source_zones_code = "sla_code",  target_table = "abs_sla.nswsla98", target_zones_code = "sla_code", into = paste("public.test", yy, sep = ""), tolerance = 0.01, subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'", eval = T)
      #cat(sql)
    }
  
  ## sql_subset(ch , "public.test01", subset = "cast(target_zone_code as text) like '%0750'", eval = T)
  ## rm(df)
  ## for(yy in zone_layers[2:4])
  ##   {
  ## #   yy <- zone_layers[4]
  ##     #cat(
  ##     df1 <- sql_join(ch, x = "test98", y = paste("test", yy, sep = ""),
  ##                    select.x = "target_zone_code",
  ##                    select.y = c("target_zone_code", "source_zone_code", "prop_olap_src_of_tgt"),
  ##                    by = "target_zone_code",
  ##                    eval = T
  ##                    )
  ## #    )
  ##     names(df1) <- c("target_zone_code", paste("code_",yy,sep=""), paste("prop_olap_",yy,sep=""))
  ##     if(yy == zone_layers[2])
  ##       {
  ##         df <- df1
  ##       } else {
  ##         df <- merge(df, df1, by = "target_zone_code")
  ##       }
  ##   }
  ## subset(df, code_01!= target_zone_code)
  ## subset(df1, target_zone_code == 105500750)
  ## # the problem is that the  matchs on target are repeated for multiple
  ## # source segments.  suggest refining postgis intersection code to
  ## # return multiple layers
  ## nrow(df)
  ## shp <- readOGR2(hostip="localhost", user="ivan_hanigan", db="django", layer="test", p = pwd)
  ## head(shp@data)
  ## choropleth(region.map=shp, stat="prop_olap_src_of_tgt")
  
#+end_src
*** COMMENT man/postgis_concordance-code
#+name:man/postgis_concordance
#+begin_src R :session *R* :tangle man/postgis_concordance.r :exports none :eval no

#+end_src

    

** postgis_concordance_multi
*** COMMENT postgis_concordance_multi-code
#+name:postgis_concordance_multi
#+begin_src R :session *R* :tangle no :exports none :eval yes
  ################################################################
  # name:postgis_concordance_multi
  ## postgis_concordance_multi <- function(conn, source_zone_layers, source_zones_code,
  ##                                 target_table, target_zones_code,
  ##                                 into = paste(source_table, "_concordance_multi", sep = ""),
  ##                                 tolerance = 0.01,
  ##                                 subset_target_table = NA,
  ##                                 eval = F
  ##                                 )
  ## {
  
  
  ##   for(i in 1:length(source_zone_layers))
  ##     {
         i  <- 1
        src_zone  <-  source_zone_layers[i]
  #       src_zone
  
        #sql <-
        postgis_concordance(
                             conn = conn
                             ,
                             source_table = src_zone
                             ,
                             source_zones_code = source_zones_code
                             ,
                             source_attributes = NA
                             ,
                             target_table = target_table
                             ,
                             target_zones_code = target_zones_code
                             ,
                             into = paste(into, i, sep = "")
                             ,
                             tolerance = tolerance
                             ,
                             subset_target_table = subset_target_table
                             ,
                             eval = T
                             )
        #cat(sql)
        #dbSendQuery(conn, sql)
        ## src_zone_name  <- gsub("\\.", "_", src_zone)
         
        ## sql  <- paste("
        ## select gid, target_fid, target_zone_code,
        ##   source_zone_code as ",src_zone_name, ", geom
        ## into ",paste(into,"_out", i, sep = ""), "
        ## from ",into,"
        ## ", sep = "")
        ## cat(sql)                  
        ## dbSendQuery(conn, sql)
        ## dbSendQuery(conn, sprintf("drop table %s", into))
         i  <- 2
        src_zone  <-  source_zone_layers[i]
        src_zone
        #      sql <-
        postgis_concordance(
                             conn = conn
                             ,
                             source_table = src_zone
                             ,
                             source_zones_code = source_zones_code
                             ,
                             source_attributes = "source_zone_code as sla00"
                             ,
                             target_table = paste(into, i-1, sep = "")
                             ,
                             target_zones_code = "target_zone_code"
                             ,
                             into = paste(into, i, sep = "")
                             ,
                             tolerance = tolerance
                             ,
                             subset_target_table = NA
                             ,
                             eval = T
                             )
        #cat(sql)
        i  <- 3
        src_zone  <-  source_zone_layers[i]
         src_zone
              sql <-
        postgis_concordance(
                             conn = conn
                             ,
                             source_table = src_zone
                             ,
                             source_zones_code = source_zones_code
                             ,
                             source_attributes = "sla00, source_zone_code as sla01"
                             ,
                             target_table = paste(into, i-1, sep = "")
                             ,
                             target_zones_code = "target_zone_code"
                             ,
                             into = paste(into, i, sep = "")
                             ,
                             tolerance = tolerance
                             ,
                             subset_target_table = NA
                             ,
                             eval = F
                             )
        cat(sql)
  #
  #    }
  #}
  
#+end_src

#+RESULTS: postgis_concordance_multi

*** COMMENT test-postgis_concordance_multi
#+name:postgis_concordance_multi
#+begin_src R :session *R* :tangle no :exports none :eval yes
  require(swishdbtools)
  ch <- connect2postgres2("django")
  pwd <- getPassword()
  
  dbSendQuery(ch, "drop table public.test")
  yy <- "98"
  sql <- postgis_concordance_multi(
                                   conn = ch
                                   ,
                                   source_zone_layers <- c('abs_sla.nswsla99','abs_sla.nswsla00', 'abs_sla.nswsla01', 'abs_sla.nswsla02', 'abs_sla.nswsla03', 'abs_sla.nswsla04', 'abs_sla.nswsla05', 'abs_sla.nswsla06', 'abs_sla.nswsla07')
                                   ,
                                   source_zones_code = "sla_code"
                                   ,
                                   target_table = "abs_sla.nswsla98"
                                   ,
                                   target_zones_code = "sla_code"
                                   ,
                                   into = "public.test98"
                                   ,
                                   tolerance = 0.01
                                   ,
                                   subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'"
                                   ,
                                   eval = T
                                   )
  cat(sql)
  sql_subset(ch , "public.test98", subset = "cast(target_zone_code as text) like '%0750'", eval = T)
  
  
  dbSendQuery(ch, "drop table public.test99")
  for(yy in zone_layers[-c(1:4)])
    {
  #    yy <- "99"
      sql <- postgis_concordance_multi(conn = ch, source_table = sprintf("abs_sla.nswsla%s", yy),  source_zones_code = "sla_code",  target_table = "abs_sla.nswsla98", target_zones_code = "sla_code", into = paste("public.test", yy, sep = ""), tolerance = 0.01, subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'", eval = T)
      #cat(sql)
    }
  
  sql_subset(ch , "public.test01", subset = "cast(target_zone_code as text) like '%0750'", eval = T)
  rm(df)
  for(yy in zone_layers[2:4])
    {
  #   yy <- zone_layers[4]
      #cat(
      df1 <- sql_join(ch, x = "test98", y = paste("test", yy, sep = ""),
                     select.x = "target_zone_code",
                     select.y = c("target_zone_code", "source_zone_code", "prop_olap_src_of_tgt"),
                     by = "target_zone_code",
                     eval = T
                     )
  #    )
      names(df1) <- c("target_zone_code", paste("code_",yy,sep=""), paste("prop_olap_",yy,sep=""))
      if(yy == zone_layers[2])
        {
          df <- df1
        } else {
          df <- merge(df, df1, by = "target_zone_code")
        }
    }
  subset(df, code_01!= target_zone_code)
  subset(df1, target_zone_code == 105500750)
  # the problem is that the  matchs on target are repeated for multiple
  # source segments.  suggest refining postgis intersection code to
  # return multiple layers
  nrow(df)
  shp <- readOGR2(hostip="localhost", user="ivan_hanigan", db="django", layer="test", p = pwd)
  head(shp@data)
  choropleth(region.map=shp, stat="prop_olap_src_of_tgt")
  
#+end_src
*** COMMENT test-pgis_conc-code
#+name:test-pgis_conc
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:test-pgis_conc
  source("R/postgis_concordance.r")
  require(swishdbtools)
  ch <- connect2postgres2("django")
  
  sequence_id  <- substr(1999:2007, 3,4)
  sequence_id
  zone_layers  <- paste("test",
                        sequence_id,
                        sep = "")
  zone_layers  
  
  sql  <- postgis_concordance(ch,
                              zone_layers[2],
                              "source_zone_code",
                              zone_layers[1],
                              "target_zone_code",
                              "test_multi",
                              eval = F
                              )
  cat(sql)
  # dev code
  
  tgt <- "98"
  for(seq_i  in 2:length(sequence_id))
    {    
      #seq_i  <- 3
      z1  <- zone_layers[seq_i -1]
      z1.1 <- sequence_id[seq_i - 1]
      z2  <- zone_layers[seq_i]
      z2.2 <- sequence_id[seq_i]
  
      if(seq_i == 2)
        {
      
  sql  <- paste("
  select tgt.target_zone_code as code_",tgt,",
    tgt.source_zone_code as code_",z1.1,",
    src.source_zone_code as code_",z2.2,",  
    st_intersection(src.geom, tgt.geom) as geom
  into concordance_multi
  from
  (
  select *
  from ",z1,"
  ) tgt,
  (
  select *
  from ",z2,"
  ) src
  where st_intersects(src.geom, tgt.geom)
  ", sep = "")
  # cat(sql)
  dbSendQuery(ch, sql)
  
        } else {
  
  sql  <- paste("
  select tgt.*,
    src.source_zone_code as code_",z2.2,",  
    st_intersection(src.geom, tgt.geom) as geom
  into concordance_multi2
  from
  (
  select *
  from concordance_multi
  ) tgt,
  (
  select *
  from ",z2,"
  ) src
  where st_intersects(src.geom, tgt.geom)
  ", sep = "")
  cat(sql)
  dbSendQuery(ch, sql)
  
        } 
  }
#+end_src

*** COMMENT man/postgis_concordance_multi-code
#+name:man/postgis_concordance_multi
#+begin_src R :session *R* :tangle man/postgis_concordance_multi.r :exports none :eval no

#+end_src

    
