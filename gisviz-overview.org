#+TITLE:gisviz overview 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Introduction
** run tests
#+name:test_project
#+begin_src R :session *R* :tangle test_project.r :exports none :eval no
  ################################################################
  # name:test_project
  require(testthat)
  test_dir('tests')
  
#+end_src

** package doc
#+name:swishdbtools-package
#+begin_src R :session *R* :tangle man/gisviz-package.Rd :exports none :eval no
\name{gisviz-package}
\alias{gisviz-package}
\alias{gisviz}
\docType{package}
\title{
GIS visualisation tools
}
\description{
General visualisations.
}
\details{
\tabular{ll}{
Package: \tab gisviz\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2012-12-18\cr
License: \tab GPL (>= 2)\cr
}
}
\author{
ivanhanigan

Maintainer: Who to complain to <ivan.hanigan@gmail.com>

}
\references{

}
\keyword{ package }
\seealso{
}
\examples{
}

#+end_src

* functions
** gGeoCode2
*** test-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle tests/test-gGeoCode2.r :exports none :eval no
  ################################################################
  # name:gGeoCode2
  source("../R/gGeoCode2.r")
  address <- "1 Lineaus way acton canberra"
  test_that("address is returned",
  {
    expect_that(nrow(gGeoCode2(address)) == 1, is_true())
  }
  )
#+end_src
*** R-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle R/gGeoCode2.r :exports none :eval no
################################################################
# name:gGeoCode2


gGeoCode2 <- function(str, first=T){
  if(!require(XML)) install.packages('XML'); require(XML)
  if(!require(RCurl)) install.packages('RCurl'); require(RCurl)
  getDocNodeVal=function(doc, path){
    sapply(getNodeSet(doc, path), function(el) xmlValue(el))
  }
  
  
  str=gsub(' ','%20',str)
  u=sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str)
  xml.response <- getURL(u, ssl.verifypeer=FALSE)
  
  doc = xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
  
  
  
  lat=getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
  lng=getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
  if(length(lng) == 1 & first == F){
    
    out<-c(str, lat, lng)
  } else if(length(lng) >= 1 & first == T) {
    out<-c(str, lat[1], lng[1])
  } else {
    out<-c(str, NA, NA)
  }
  out<-as.data.frame(t(out))
  names(out) <- c('address','lat','long')
  return(out)
  
}

#+end_src
*** man-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle man/gGeoCode2.Rd :exports none :eval no
\name{gGeoCode2}
\alias{gGeoCode2}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
gGeoCode2
}
\description{
This is an HTTPS security enhanced version of the gGeoCode function from Ezgraphs. GoogleGeocodeMap.R, 2010. https://github.com/ezgraphs/R-Programs/blob/master/GoogleGeocodeMap.R. 
}
\usage{
gGeoCode2(str, first = T)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{str}{
address string
}
  \item{first}{
google may return multiple hits.  just return the first.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
%%  ~~who you are~~
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
address <- "1 Lineaus way acton canberra"
gGeoCode2(address)
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ geocoding }
\keyword{ address }% __ONLY ONE__ keyword per line

#+end_src

** get.levels
*** test-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src
*** R-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle R/get.levels.r :exports none :eval no
################################################################
# name:get.levels

################################################################
# name:cells

################################################################################
# Function to return bin sizes for the map key            
################################################################################
get.levels = function(stat,cellsmap, probs=seq(0,1,.2)){
  cells.map=cellsmap
  bins = quantile(cells.map@data[,stat], probs, na.rm=T)  
  binlevels = cut(cells.map@data[,stat], bins, include.lowest=TRUE)
  groups = strsplit(levels(binlevels), ",")
# Get the beginning value for each group
  begins = sapply(groups, '[[', 1)
  begins = substr(begins, 2, nchar(begins))
# Get the beginning value for each group
  ends = sapply(groups, '[[', 2)
  ends = substr(ends, 1, nchar(ends)-1)
# Put begins and ends together into labels
  level.labels = paste(begins, ends, sep = " - ")
  qlevels = paste(as.character(probs[2:length(probs)]*100),"%:",sep="") 
  level.labels = paste(qlevels, level.labels)  
return(level.labels) 
}  
#get.levels(cellsmap=d,stat='DAILY_MAX_')

#+end_src
*** man-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src

** plotMap
*** test-plotMap
#+name:plotMap
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:plotMap

#+end_src
*** R-plotMap
#+name:plotMap
#+begin_src R :session *R* :tangle R/plotMap.r :exports none :eval no

################################################################
# name:plotMap
################################################################################
# Write a mapping function, form of which was taken from here:
# http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r             
################################################################################

if (!require(maptools)) install.packages('maptools', repos='http://cran.csiro.au'); require(maptools)
if (!require(RColorBrewer)) install.packages('RColorBrewer', repos='http://cran.csiro.au'); require(RColorBrewer)
# library(maptools)
# library(RColorBrewer)



plotMap = function(stat=NA,plotdir = getwd(),probs=seq(0,1,.2), outfile = NA,  maptitle = 'map',  cellsmap=NA,region.map=NA){
  level.labels = get.levels(cellsmap=cellsmap,stat=stat,probs=probs)
# create a new variable in cells.map to bin the data into categories 
  cells.map=cellsmap
  bins = quantile(cells.map@data[,stat], probs, na.rm=T)
  cells.map@data$bins = cut(cells.map@data[,stat], bins, include.lowest=TRUE)
# Replace the charachter "levels" attribute with character colors
  col.vec = brewer.pal(length(level.labels),"YlOrRd")
  levels(cells.map@data$bins) <- col.vec
# Open a windows graphics device so that we can see what's happening 
# windows(11.7,8.3)
# Split the figure to leave room at the right for a legend, and room
# at the top margin for a title   
  par(fig = c(0,0.8,0,1), mar=c(2,2,2,0))
# plot the map object with no border around the rectangels, and with colors
# dictated by new variable we created, which holds the colours as its levels
# paramater.    
  plot(cells.map, 
    border = FALSE, 
    axes = FALSE, 
    las = 1,
    col = as.character(cells.map@data$bins))
axis(2)
axis(1)
box()   
  plot(region.map, add=TRUE, lwd=1)
  mtext(maptitle, side = 3, cex = 2, line = -0.5)
  par(fig = c(0.8,1,0,1), mar=c(0,0,0,0), new = FALSE)  
  legend("left", level.labels, fill=col.vec, bty="n", xpd=TRUE, 
        title="Legend")

if(!is.na(outfile)){
# # paste windows device to jpeg device
  dev.copy(jpeg, file = paste(plotdir, '/',outfile,'.jpg', sep = ""), width = 11.75, 
    height = 8.3, units = "in", pointsize = 12, quality = 75, bg = "white", 
    res = 150, restoreConsole = TRUE) 
  graphics.off()
}
  }

  
# get.levels(cellsmap=d,stat='DAILY_MAX_',probs=seq(0,1,.1))
# plotMap(cellsmap=d,stat='DAILY_MAX_',region.map=grd,probs=seq(0,1,.1))

#+end_src
*** man-plotMap
#+name:plotMap
#+begin_src R :session *R* :tangle man/plotMap.Rd :exports none :eval no
\name{plotMap}
\alias{plotMap}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
Plot a Choropleth Map
}
\description{
Plot a Choropleth Map
}
\usage{
plotMap(stat = NA, plotdir = getwd(), probs = seq(0, 1, 0.2), outfile = NA, maptitle = "map", cellsmap = NA, region.map = NA)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{stat}{
the column with the statistic to be plotted
}
  \item{plotdir}{
write out a graph
}
  \item{probs}{
quantiles at which to break, default is quintiles, limit is 9
}
  \item{outfile}{
output map file
}
  \item{maptitle}{

}
  \item{cellsmap}{
if using a raster, can be same as region.map
}
  \item{region.map}{
if using a polygon
}
}
\value{
a map
}
\references{
http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r

Eduardo Leoni
http://stackoverflow.com/a/1261288
}
\author{
ivanhanigan
}


#+end_src
** postgis_concordance
*** COMMENT test-postgis_concordance
#+name:postgis_concordance
#+begin_src R :session *R* :tangle tests/test-postgis_concordance.r :exports none :eval yes
  require(swishdbtools)
  ch <- connect2postgres2("django")
  sql <- postgis_concordance(conn = ch, source_table = "abs_sla.nswsla01",
                      target_table = "abs_sla.nswsla98",
                             into = "public.test",
                      tolerance = 0.01,
                      subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'",
                      eval = F)
  cat(sql)
  
#+end_src
*** COMMENT postgis_concordance-code
#+name:postgis_concordance
#+begin_src R :session *R* :tangle R/postgis_concordance.r :exports none :eval yes
  ################################################################
  # name:postgis_concordance
  postgis_concordance <- function(conn, source_table, target_table,
                                  into = paste(source_table, "_concordance", sep = ""),
                                 tolerance = 0.01,
                                 subset_target_table = NA,
                                 eval = F)
  {
  sql <- paste("
  select source_sla_code, source_zones, target_sla_code, prop_olap_src_of_tgt,
    prop_olap_src_segment_of_src_orig, geom
  frominto
  (
  select    src.sla_code as source_sla_code,
            tgt.sla_code as target_sla_code, source_zones,
            st_intersection(src.geom, tgt.geom) as geom,
            st_area(src.geom) as src_area,
            st_area(tgt.geom) as tgt_area,
            st_area(st_intersection(src.geom, tgt.geom )) as area_overlap,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(tgt.geom) as
            prop_olap_src_of_tgt,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(src.geom) as
            prop_olap_src_segment_of_src_orig
  from
  (
  select sla_code, geom, cast('",source_table,"' as text) as source_zones
  from ",source_table,"
  ) src,
  (
  select sla_code, geom
  from ",target_table,"
  ) tgt
  where st_intersects(src.geom, tgt.geom)
  ) concorded
  where prop_olap_src_of_tgt > ",tolerance,";
  grant select on ",into," to public_group;
  ", sep = "")

  # if table exists add inserts, else
  sql <-  gsub("frominto", paste("into ", into, "\nfrom", sep = ""), sql)
  sql <- c(sql,paste("\n
  alter table ",into," add column gid serial primary key;
  ALTER TABLE ",into," ALTER COLUMN geom SET NOT NULL;
  CREATE INDEX ",strsplit(into, "\\.")[[1]][2],"_gist on ",into," using GIST(geom);
  ALTER TABLE ",into," CLUSTER ON ",strsplit(into, "\\.")[[1]][2],"_gist;
  ", sep = "")
  )
  
  if(!is.na(subset_target_table))
    {
      sql <- gsub(") tgt", paste("where ", subset_target_table, "\n) tgt", sep = ""), sql)
    }
  if(eval)
    {
      dbSendQuery(conn, sql)
    } else {
      return(sql)
    }
  
  }
  
#+end_src

#+RESULTS: postgis_concordance

