#+TITLE:gisviz overview 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* Introduction
** DESCRIPTION-code
#+name:DESCRIPTION
#+begin_src R :session *R* :tangle DESCRIPTION :exports none :eval no :padline no
Package: gisviz
Type: Package
Title: GIS visualisation and data manipulation tools
Version: 1.0
Date: 2012-12-18
Author: ivanhanigan
Maintainer: <ivan.hanigan@gmail.com>
Depends: RCurl, XML, ggmap, maps, maptools, RColorBrewer, spdep, rgdal
Description:  Functions I modified or created for visualising GIS data in population health and environmental science projects.
License: GPL (>= 2)
#+end_src

** run tests
#+name:test_project
#+begin_src R :session *R* :tangle test_project.r :exports none :eval no
  ################################################################
  # name:test_project
  require(testthat)
  test_dir('tests')
  
#+end_src

** package doc
#+name:swishdbtools-package
#+begin_src R :session *R* :tangle man/gisviz-package.Rd :exports none :eval no
\name{gisviz-package}
\alias{gisviz-package}
\alias{gisviz}
\docType{package}
\title{
GIS visualisation tools
}
\description{
General visualisations.
}
\details{
\tabular{ll}{
Package: \tab gisviz\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2012-12-18\cr
License: \tab GPL (>= 2)\cr
}
}
\author{
ivanhanigan

Maintainer: Who to complain to <ivan.hanigan@gmail.com>

}
\references{

}
\keyword{ package }
\seealso{
}
\examples{
}

#+end_src

**  loadall-code
#+name:loadall
#+begin_src R :session *R* :tangle no :exports none :eval yes
  ################################################################
  # name:loadall
  #dir("R")
  require(devtools)
  load_all()
  
#+end_src

#+RESULTS: loadall

* functions
** gGeoCode2
*** test-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle tests/test-gGeoCode2.r :exports none :eval no
  ################################################################
  # name:gGeoCode2
  source("../R/gGeoCode2.r")
  address <- "1 Lineaus way acton canberra"
  test_that("address is returned",
  {
    expect_that(nrow(gGeoCode2(address)) == 1, is_true())
  }
  )
#+end_src
*** R-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle R/gGeoCode2.r :exports none :eval no
################################################################
# name:gGeoCode2


gGeoCode2 <- function(str, first=T){
  if(!require(XML)) install.packages('XML'); require(XML)
  if(!require(RCurl)) install.packages('RCurl'); require(RCurl)
  getDocNodeVal=function(doc, path){
    sapply(getNodeSet(doc, path), function(el) xmlValue(el))
  }
  
  
  str=gsub(' ','%20',str)
  u=sprintf('https://maps.googleapis.com/maps/api/geocode/xml?sensor=false&address=%s',str)
  xml.response <- getURL(u, ssl.verifypeer=FALSE)
  
  doc = xmlTreeParse(xml.response, useInternal=TRUE, asText=TRUE)
  
  
  
  lat=getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lat')
  lng=getDocNodeVal(doc, '/GeocodeResponse/result/geometry/location/lng')
  if(length(lng) == 1 & first == F){
    
    out<-c(str, lat, lng)
  } else if(length(lng) >= 1 & first == T) {
    out<-c(str, lat[1], lng[1])
  } else {
    out<-c(str, NA, NA)
  }
  out<-as.data.frame(t(out))
  names(out) <- c('address','lat','long')
  return(out)
  
}

#+end_src
*** man-gGeoCode2
#+name:gGeoCode2
#+begin_src R :session *R* :tangle man/gGeoCode2.Rd :exports none :eval no
\name{gGeoCode2}
\alias{gGeoCode2}
%- Also NEED an '\alias' for EACH other topic documented here.
\title{
gGeoCode2
}
\description{
This is an HTTPS security enhanced version of the gGeoCode function from Ezgraphs. GoogleGeocodeMap.R, 2010. https://github.com/ezgraphs/R-Programs/blob/master/GoogleGeocodeMap.R. 
}
\usage{
gGeoCode2(str, first = T)
}
%- maybe also 'usage' for other objects documented here.
\arguments{
  \item{str}{
address string
}
  \item{first}{
google may return multiple hits.  just return the first.
}
}
\details{
%%  ~~ If necessary, more details than the description above ~~
}
\value{
%%  ~Describe the value returned
%%  If it is a LIST, use
%%  \item{comp1 }{Description of 'comp1'}
%%  \item{comp2 }{Description of 'comp2'}
%% ...
}
\references{
%% ~put references to the literature/web site here ~
}
\author{
%%  ~~who you are~~
}
\note{
%%  ~~further notes~~
}

%% ~Make other sections like Warning with \section{Warning }{....} ~

\seealso{
%% ~~objects to See Also as \code{\link{help}}, ~~~
}
\examples{
address <- "1 Lineaus way acton canberra"
gGeoCode2(address)
}
% Add one or more standard keywords, see file 'KEYWORDS' in the
% R documentation directory.
\keyword{ geocoding }
\keyword{ address }% __ONLY ONE__ keyword per line

#+end_src

** get.levels
*** test-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src
*** R-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle R/get.levels.r :exports none :eval no
################################################################
# name:get.levels

################################################################
# name:cells

################################################################################
# Function to return bin sizes for the map key            
################################################################################
get.levels = function(stat,cellsmap, probs=seq(0,1,.2)){
  cells.map=cellsmap
  bins = quantile(cells.map@data[,stat], probs, na.rm=T)  
  binlevels = cut(cells.map@data[,stat], bins, include.lowest=TRUE)
  groups = strsplit(levels(binlevels), ",")
# Get the beginning value for each group
  begins = sapply(groups, '[[', 1)
  begins = substr(begins, 2, nchar(begins))
# Get the beginning value for each group
  ends = sapply(groups, '[[', 2)
  ends = substr(ends, 1, nchar(ends)-1)
# Put begins and ends together into labels
  level.labels = paste(begins, ends, sep = " - ")
  qlevels = paste(as.character(probs[2:length(probs)]*100),"%:",sep="") 
  level.labels = paste(qlevels, level.labels)  
return(level.labels) 
}  
#get.levels(cellsmap=d,stat='DAILY_MAX_')

#+end_src
*** man-get.levels
#+name:get.levels
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:get.levels

#+end_src

** plotMyMap
*** test-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle no :exports none :eval no
  ################################################################
  # name:plotMyMap
  plotMyMap('canberra', googlemaps = T)
#+end_src
*** R-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle R/plotMyMap.R :exports none :eval no
################################################################
# name:plotMyMap
plotMyMap <- function(location, xl = c(-180,180), yl = c(-50,50), googlemaps = F){
  map('world', xlim = xl, ylim = yl)
  box()
  if(diff(xl) > 300) {
    axis(1);axis(2)
  } else {
    map.scale(ratio=F)
  }
  if(googlemaps == T){
    points(geocode(location), pch =16, col = 'red')
  } else {
    points(location[1,], pch =16, col = 'red')
  }
  
}


#+end_src
*** man-plotMyMap
#+name:plotMyMap
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:plotMyMap

#+end_src

** choropleth
*** test-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle no :exports none :eval yes
  ################################################################
  # name:choropleth
  require(gisviz)
  require(devtools)
  load_all()
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  class(eire)
  eire@data
  
  plot(eire)
  
  eire2 <- spTransform(eire, CRS("+proj=longlat +datum=WGS84"))
  ?choropleth
  png("test.png")
  choropleth(stat="INCOME", region.map=eire2, scalebar = T, xl = c(-8,-6), yl = c(52,53))
  dev.off()
  
#+end_src

#+RESULTS: choropleth

*** R-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle R/choropleth.r :exports none :eval no
  
  ################################################################
  # name:choropleth
  ################################################################
  # A general mapping function, form of which was taken from here:
  # http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r
  ################################################################
  
  choropleth <- function(maptitle = 'map', stat=NA, region.map=NA,
                      brew.pal = "RdYlBu",
                      invert.brew.pal = TRUE,
                      cellsmap=region.map, scalebar = TRUE,
                      xl = NA, yl = NA,
                      probs=seq(0,1,.2)
                      )
  {
    level.labels <- get.levels(cellsmap=cellsmap,stat=stat,probs=probs)
    # create a new variable in cells.map to bin the data into categories
    cells.map <- cellsmap
    bins <- quantile(cells.map@data[,stat], probs, na.rm=T)
    cells.map@data$bins <- cut(cells.map@data[,stat],
                               bins, include.lowest=TRUE
                               )
    # Replace the character "levels" attribute with character colors
    col.vec <- brewer.pal(length(level.labels),brew.pal)
    if(invert.brew.pal == TRUE) col.vec <- col.vec[length(col.vec):1]
    levels(cells.map@data$bins) <- col.vec
    # Open a windows graphics device so that we can see what's happening
    # windows(11.7,8.3)
    # Split the figure to leave room at the right for a legend, and room
    # at the top margin for a title
    par(fig = c(0,0.7,0,1), mar=c(2,2,2,0))
    # plot the map object with no border around the rectangels, and with colors
    # dictated by new variable we created, which holds the colours as its levels
    # paramater.
  
    if(!is.na(xl)  & !is.na(yl))
      {
        plot(cells.map,
             border = FALSE,
             axes = FALSE,
             las = 1,
             col = as.character(cells.map@data$bins),
             xlim = xl, ylim = yl
             )
      } else {
        plot(cells.map,
             border = FALSE,
             axes = FALSE,
             las = 1,
             col = as.character(cells.map@data$bins)
             )
      }
    if(scalebar == FALSE)
      {
        axis(1);axis(2)
      } else {
        map.scale(ratio=F)
      }
  
    box()
    plot(region.map, add=TRUE, lwd=1)
    mtext(maptitle, side = 3, cex = 2, line = 0)
    par(fig = c(0.7,1,0,1), mar=c(0,0,0,0), new = FALSE)
    legend("left", level.labels, fill=col.vec, bty="n", xpd=TRUE,
          title="Legend")
  
  }
  
#+end_src
*** man-choropleth
#+name:choropleth
#+begin_src R :session *R* :tangle man/choropleth.Rd :exports none :eval no
  \name{choropleth}
  \alias{choropleth}
  %- Also NEED an '\alias' for EACH other topic documented here.
  \title{
  Plot a Choropleth Map
  }
  \description{
  Plot a Choropleth Map
  }
  \usage{
  choropleth(stat = NA, plotdir = getwd(), probs = seq(0, 1, 0.2), outfile = NA, maptitle = "map", cellsmap = NA, region.map = NA)
  }
  %- maybe also 'usage' for other objects documented here.
  \arguments{
    \item{maptitle}{
  
  }
    \item{stat}{
  the column with the statistic to be plotted
  }
    \item{region.map}{
  if using a polygon
  }
   \item{brew.pal}{
  defaults to RdYlBu.  use display.brewer.all() to see options
  }
   \item{invert.brew.pal}{
   inverted colour ramp
  }
    \item{cellsmap}{
  if using a raster etc can be used to show pattern inside polygons, defaults to region.map and therefore overlays.
  }
    \item{scalebar}{
  if set to false then the axes are ploted
  }
  \item{xl}{
  xlim values
}
\item{yl}{
ylim values
}
    \item{probs}{
  quantiles at which to break, default is quintiles, limit is 9
  }
  
  
  
  }
  \value{
  a map
  }
  \references{
  http://stackoverflow.com/questions/1260965/developing-geographic-thematic-maps-with-r
  
  Eduardo Leoni
  http://stackoverflow.com/a/1261288
  }
  \author{
  ivanhanigan
  }
  \examples{
  require(gisviz)
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  eire2 <- spTransform(eire, CRS("+proj=longlat +datum=WGS84"))
  png("test.png")
  choropleth(stat="INCOME", region.map=eire2, scalebar = T, xl = c(-8,-6), yl = c(52,53))
  dev.off()

  Sr1 = Polygon(cbind(c(2,4,4,1,2),c(2,3,5,4,2)))
  Sr2 = Polygon(cbind(c(5,4,2,5),c(2,3,2,2)))
  Sr3 = Polygon(cbind(c(4,4,5,10,4),c(5,3,2,5,5)))
  Sr4 = Polygon(cbind(c(5,6,6,5,5),c(4,4,3,3,4)), hole = TRUE)
  Srs1 = Polygons(list(Sr1), "s1")
  Srs2 = Polygons(list(Sr2), "s2")
  Srs3 = Polygons(list(Sr3, Sr4), "s3/4")
  SpP = SpatialPolygons(list(Srs1,Srs2,Srs3), 1:3)
  plot(SpP, col = 1:3, pbg="white")
  attr = data.frame(a=1:3, b=3:1, row.names=c("s3/4", "s2", "s1"))
  SrDf = SpatialPolygonsDataFrame(SpP, attr)
  plot(SrDf)
  choropleth("title", stat = "b",region.map= SrDf)
  }
  
#+end_src
*** TODO versions
*** COMMENT arribas-code
#+name:arribas
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:arribas https://raw.github.com/darribas/darribas-R-tools/master/choropleth.r
##################################
# Choropleth: thematic maps in R #
##################################

# Author: Daniel Arribas-Bel <daniel.arribas.bel@gmail.com>
# Copyright 2010 by Daniel Arribas-Bel 
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.

#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    See: <http://creativecommons.org/licenses/GPL/2.0/> or <http://www.gnu.org/licenses/>

library(maptools)
library(spatial)
library(RColorBrewer)
library(classInt)

gpclibPermit()

dbf.choropleths <- function(link, dims=FALSE, excluded=c(), 
                            classMethod='quantile', bins=5,
                            border='black'){
    shp <- paste(link, 'shp', sep='.')
    dbf <- paste(link, 'dbf', sep='.')
    png <- paste(link, '_choropleths.png', sep='')
    dbf <- read.dbf(dbf)
    k <- length(dbf[1, ])
    png(png, width=4670, height=2000, bg='white')
    if(dims==FALSE){
        s = sqrt(k)
        s = (s - s%%1) + 1
        dims = c(s, s)
    }
    par = par(mfrow=dims)
    vars <- names(dbf)
    vars <- vars[!(vars %in% excluded)]

    for(var in seq(length(vars))){
        print(paste('Building var', vars[var]))
        name <- vars[var]

        choropleth(shp, name, bins=bins, style=classMethod,
        title=name, font=10, legend=FALSE, border=border)
        }

    dev.off()
}

choropleth <- function(shp, field, png=FALSE, bins=FALSE, bgLayer=FALSE,
        colPal="Blues", style="hclust", lwd=0.5, title='', sub='', xlab='',
        ylab='', legend=TRUE, font=4, tcol='black', texto='', width=960,
        height=960, border='black'){
            # If not 'bins' -> categorical data
            poly <- readShapeSpatial(shp, force_ring=TRUE)
            attach(poly@data, warn.conflicts=FALSE)
            data <- get(field)
            if(bins==FALSE){
                bins <- length(unique(get(field)))
                colCode <- colCoder(poly, field, colPal)
                leyenda <- colCode$legend
                fill <- colCode$paleta
                colCode <- colCode$colVec
                } else {
                colors <- brewer.pal(bins, colPal)
                class = classIntervals(data, bins, style)
                colCode = findColours(class, colors, digits=4)
                leyenda = names(attr(colCode, "table"))
                fill = attr(colCode, "palette")
                }
            detach(poly@data)
            #
            if(png!=FALSE){
                png(png, width=width, height=height, bg="white")
                #png(png, width=960, height=960, bg="white")
                }
            if(bgLayer!=FALSE){
                polyBg <- readShapeSpatial(bgLayer, force_ring=TRUE)
                plot(polyBg, lwd=lwd, border=border)
                plot(poly, add=TRUE, col=colCode, lwd=lwd)
                } else {
                plot(poly, col=colCode, lwd=lwd, border=border)
                }
            title(main=title, sub=sub, xlab=xlab, ylab=ylab, cex.main=font,
            col.main=tcol, cex.sub=font, cex.lab=font)
            if(texto!=''){
                text(-1, -1, texto)
                }
            if(legend==TRUE){legend("topleft", legend=leyenda, fill=fill, cex=0.75, bty="n")}
            if(png!=FALSE){
                dev.off()
                }
            "Map created"
            }

colCoder <- function(poly, var, colPal){
            attach(poly@data, warn.conflicts=FALSE)
            uniques <- unique(get(var))
            paleta <- brewer.pal(length(uniques), colPal)
            colVec <- mat.or.vec(length(get(var)), 1)
            for(row in seq(length(get(var)))){
                ind <- which(uniques == get(var)[row])
                colVec[row] <- paleta[ind]
                }
            detach(poly@data)
            res <- list(colVec=colVec, legend=uniques, paleta=paleta)
            res
            }


#+end_src

** postgis_concordance
*** COMMENT test-postgis_concordance
#+name:postgis_concordance
#+begin_src R :session *R* :tangle tests/test-postgis_concordance.r :exports none :eval yes
  require(swishdbtools)
  ch <- connect2postgres2("django")
  sql <- postgis_concordance(conn = ch, source_table = "abs_sla.nswsla01",
                             target_table = "abs_sla.nswsla98",
                             into = "public.test",
                             tolerance = 0.01,
                             subset_target_table = "substr(cast(sla_code as text), 1, 3) = '105'",
                             eval = T
                             )
  #cat(sql)
  shp <- readOGR2(hostip="localhost", user="ivan_hanigan", db="django", layer="test", p="kazoowazoo")
  head(shp@data)
  choropleth(region.map=shp, stat="prop_olap_src_of_tgt")
#+end_src
*** COMMENT postgis_concordance-code
#+name:postgis_concordance
#+begin_src R :session *R* :tangle R/postgis_concordance.r :exports none :eval yes
  ################################################################
  # name:postgis_concordance
  postgis_concordance <- function(conn, source_table, target_table,
                                  into = paste(source_table, "_concordance", sep = ""),
                                 tolerance = 0.01,
                                 subset_target_table = NA,
                                 eval = F)
  {
  sql <- paste("
  select source_sla_code, source_zones, target_sla_code, prop_olap_src_of_tgt,
    prop_olap_src_segment_of_src_orig, geom
  frominto
  (
  select    src.sla_code as source_sla_code,
            tgt.sla_code as target_sla_code, source_zones,
            st_intersection(src.geom, tgt.geom) as geom,
            st_area(src.geom) as src_area,
            st_area(tgt.geom) as tgt_area,
            st_area(st_intersection(src.geom, tgt.geom )) as area_overlap,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(tgt.geom) as
            prop_olap_src_of_tgt,
            st_area(st_intersection(src.geom, tgt.geom
                                    ))/st_area(src.geom) as
            prop_olap_src_segment_of_src_orig
  from
  (
  select sla_code, geom, cast('",source_table,"' as text) as source_zones
  from ",source_table,"
  ) src,
  (
  select sla_code, geom
  from ",target_table,"
  ) tgt
  where st_intersects(src.geom, tgt.geom)
  ) concorded
  where prop_olap_src_of_tgt > ",tolerance,";
  grant select on ",into," to public_group;
  ", sep = "")

  # if table exists add inserts, else
  sql <-  gsub("frominto", paste("into ", into, "\nfrom", sep = ""), sql)
  sql <- c(sql,paste("\n
  alter table ",into," add column gid serial primary key;
  ALTER TABLE ",into," ALTER COLUMN geom SET NOT NULL;
  CREATE INDEX ",strsplit(into, "\\.")[[1]][2],"_gist on ",into," using GIST(geom);
  ALTER TABLE ",into," CLUSTER ON ",strsplit(into, "\\.")[[1]][2],"_gist;
  ", sep = "")
  )
  
  if(!is.na(subset_target_table))
    {
      sql <- gsub(") tgt", paste("where ", subset_target_table, "\n) tgt", sep = ""), sql)
    }
  if(eval)
    {
      dbSendQuery(conn, sql)
    } else {
      return(sql)
    }
  
  }
  
#+end_src

#+RESULTS: postgis_concordance

** adjacency_df
*** R-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle R/adjacency_df.r :exports none :eval no
################################################################
# name:adjacency_df
adjacency_df <- function(NB, shp, zone_id)
  {
    adjacencydf <- as.data.frame(matrix(NA, nrow = 0, ncol = 2))
    for(i in 1:length(NB))
    {
      if(length(shp[[zone_id]][NB[[i]]]) == 0) next
      adjacencydf <- rbind(adjacencydf, cbind(as.character(shp[[zone_id]][i]),as.character(shp[[zone_id]][NB[[i]]])))
    }
    return(adjacencydf)
  }
#+end_src
*** test-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle tests/test-adjacency_df.r :exports none :eval no
  ################################################################
  # name:adjacency_df
  require(devtools)
  load_all()
  require(spdep)
  fn <- system.file("etc/shapes/eire.shp", package="spdep")[1]
  prj <- CRS("+proj=utm +zone=30 +units=km")
  eire <- readShapeSpatial(fn, ID="names", proj4string=prj)
  class(eire)
  eire@data
  
  plot(eire)
  nb <- poly2nb(eire)
  head(nb)
  eire[['names']][1]
  eire[['names']][nb[[1]]]
  plot(nb, coordinates(eire), add=TRUE, pch=".", lwd=2)
  adj <- adjacency_df(NB = nb, shp = eire, zone_id = 'names')
  adj
  
  
#+end_src
*** man-adjacency_df
#+name:adjacency_df
#+begin_src R :session *R* :tangle no :exports none :eval no
################################################################
# name:adjacency_df

#+end_src
    
